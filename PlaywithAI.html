<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chess Pro | AI Debug Mode</title>
    <style>
        :root {
            --bg: #0f172a; --panel: #1e293b; --accent: #38bdf8;
            --white-sq: #f1f5f9; --black-sq: #64748b;
        }
        body { background: var(--bg); color: white; font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; margin: 0; }
        
        .game-info { background: var(--panel); padding: 15px 30px; border-radius: 12px; margin-bottom: 20px; border: 1px solid #334155; display: flex; gap: 20px; align-items: center; }
        
        /* Board Reset */
        #board {
            display: grid; grid-template-columns: repeat(8, 60px); grid-template-rows: repeat(8, 60px);
            border: 6px solid #1e293b; border-radius: 4px; user-select: none;
        }
        .sq { width: 60px; height: 60px; display: flex; justify-content: center; align-items: center; font-size: 40px; cursor: pointer; position: relative; }
        .white { background: var(--white-sq); color: #334155; }
        .black { background: var(--black-sq); color: #f1f5f9; }
        
        /* Glitch Fix: Proper highlighting */
        .selected { background: #7dd3fc !important; box-shadow: inset 0 0 10px rgba(0,0,0,0.2); }
        .hint-dot { width: 14px; height: 14px; background: rgba(56, 189, 248, 0.5); border-radius: 50%; position: absolute; pointer-events: none; }
        
        .btn-row { margin-top: 25px; display: flex; gap: 10px; }
        .btn { padding: 10px 20px; border-radius: 6px; border: none; font-weight: bold; cursor: pointer; text-decoration: none; background: #334155; color: white; }
        .btn-home { background: var(--accent); color: #0f172a; }
    </style>
</head>
<body>

    <div class="game-info">
        <div id="turn-status">White's Turn</div>
        <div id="ai-thinking" style="display:none; color: #fbbf24;">ü§ñ Thinking...</div>
    </div>

    <div id="board"></div>

    <div class="btn-row">
        <a href="index.html" class="btn btn-home">Back to Hub</a>
        <button class="btn" onclick="resetGame()">Force Reset</button>
    </div>

    <script>
        // Use a "const" for icons to prevent accidental overrides
        const ICONS = { r:'‚ôú', n:'‚ôû', b:'‚ôù', q:'‚ôõ', k:'‚ôö', p:'‚ôü', R:'‚ôñ', N:'‚ôò', B:'‚ôó', Q:'‚ôï', K:'‚ôî', P:'‚ôô' };
        
        let board = [];
        let turn = 'W';
        let selected = null;
        let isGameOver = false;

        function resetGame() {
            board = [
                ['r','n','b','q','k','b','n','r'],
                ['p','p','p','p','p','p','p','p'],
                ['','','','','','','',''],['','','','','','','',''],
                ['','','','','','','',''],['','','','','','','',''],
                ['P','P','P','P','P','P','P','P'],
                ['R','N','B','Q','K','B','N','R']
            ];
            turn = 'W';
            selected = null;
            isGameOver = false;
            updateUI();
            render();
        }

        function render() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';
            
            // Get legal moves for selection highlight
            let hints = (selected) ? getLegalMoves(selected.r, selected.c) : [];

            for(let r=0; r<8; r++) {
                for(let c=0; c<8; c++) {
                    const sq = document.createElement('div');
                    sq.className = `sq ${(r+c)%2===0 ? 'white' : 'black'}`;
                    
                    if(selected?.r === r && selected?.c === c) sq.classList.add('selected');
                    
                    // Render Piece
                    if(board[r][c]) {
                        const span = document.createElement('span');
                        span.innerText = ICONS[board[r][c]];
                        sq.appendChild(span);
                    }

                    // Render Hint Dots
                    if(hints.some(h => h.r === r && h.c === c)) {
                        const dot = document.createElement('div');
                        dot.className = 'hint-dot';
                        sq.appendChild(dot);
                    }

                    sq.onclick = () => handleInput(r, c);
                    boardEl.appendChild(sq);
                }
            }
        }

        function handleInput(r, c) {
            if(turn !== 'W' || isGameOver) return;

            const target = board[r][c];
            const isFriendly = target && target === target.toUpperCase();

            if(selected) {
                if(isFriendly) {
                    selected = (selected.r === r && selected.c === c) ? null : {r, c};
                } else {
                    if(movePiece(selected.r, selected.c, r, c)) {
                        selected = null;
                        if(!isGameOver) {
                            turn = 'B';
                            updateUI();
                            setTimeout(aiMove, 800);
                        }
                    } else {
                        selected = null;
                    }
                }
            } else if(isFriendly) {
                selected = {r, c};
            }
            render();
        }

        function movePiece(r1, c1, r2, c2) {
            if(!validateMove(r1, c1, r2, c2)) return false;

            const captured = board[r2][c2];
            if(captured.toLowerCase() === 'k') {
                isGameOver = true;
                setTimeout(() => { alert(turn === 'W' ? "You Win!" : "AI Wins!"); resetGame(); }, 100);
            }

            board[r2][c2] = board[r1][c1];
            board[r1][c1] = '';
            return true;
        }

        function aiMove() {
            if(isGameOver) return;
            
            let moves = [];
            for(let r=0; r<8; r++) {
                for(let c=0; c<8; c++) {
                    if(board[r][c] && board[r][c] === board[r][c].toLowerCase()) {
                        let available = getLegalMoves(r, c);
                        available.forEach(m => moves.push({f: {r,c}, t: m}));
                    }
                }
            }

            if(moves.length > 0) {
                // Glitch Fix: Sort to prioritize captures so AI isn't "stupid"
                moves.sort((a, b) => (board[b.t.r][b.t.c] !== '' ? 1 : 0) - (board[a.t.r][a.t.c] !== '' ? 1 : 0));
                const chosen = moves[0]; 
                movePiece(chosen.f.r, chosen.f.c, chosen.t.r, chosen.t.c);
            }

            turn = 'W';
            updateUI();
            render();
        }

        function updateUI() {
            document.getElementById('turn-status').innerText = turn === 'W' ? "White's Turn" : "AI Turn";
            document.getElementById('ai-thinking').style.display = turn === 'B' ? 'block' : 'none';
        }

        function validateMove(r1, c1, r2, c2) {
            const p = board[r1][c1];
            const target = board[r2][c2];
            if(target && (target === target.toUpperCase()) === (p === p.toUpperCase())) return false;

            const dr = r2-r1, dc = c2-c1;
            const adr = Math.abs(dr), adc = Math.abs(dc);
            const type = p.toLowerCase();

            // Sliding Logic (Rook, Bishop, Queen)
            if(['r','b','q'].includes(type)) {
                let sr = Math.sign(dr), sc = Math.sign(dc);
                let currR = r1 + sr, currC = c1 + sc;
                while(currR !== r2 || currC !== c2) {
                    if(board[currR][currC] !== '') return false;
                    currR += sr; currC += sc;
                }
            }

            switch(type) {
                case 'p':
                    const dir = (p === 'P') ? -1 : 1;
                    if(dc === 0 && target === '' && dr === dir) return true;
                    if(dc === 0 && target === '' && dr === 2*dir && r1 === (p === 'P' ? 6 : 1) && board[r1+dir][c1] === '') return true;
                    if(adc === 1 && dr === dir && target !== '') return true;
                    return false;
                case 'n': return (adr === 2 && adc === 1) || (adr === 1 && adc === 2);
                case 'r': return dr === 0 || dc === 0;
                case 'b': return adr === adc;
                case 'q': return dr === 0 || dc === 0 || adr === adc;
                case 'k': return adr <= 1 && adc <= 1;
            }
            return false;
        }

        function getLegalMoves(r, c) {
            let moves = [];
            for(let tr=0; tr<8; tr++) {
                for(let tc=0; tc<8; tc++) {
                    if(validateMove(r, c, tr, tc)) moves.push({r: tr, c: tc});
                }
            }
            return moves;
        }

        // Initialize game
        resetGame();
        </script>
</body>
</html>